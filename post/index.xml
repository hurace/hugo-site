<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 晓瑞</title>
    <link>https://hurace.github.io/post/</link>
    <description>Recent content in Posts on 晓瑞</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 09 Apr 2021 16:14:16 +0800</lastBuildDate><atom:link href="https://hurace.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go方法集</title>
      <link>https://hurace.github.io/post/go%E6%96%B9%E6%B3%95%E9%9B%86/</link>
      <pubDate>Fri, 09 Apr 2021 16:14:16 +0800</pubDate>
      
      <guid>https://hurace.github.io/post/go%E6%96%B9%E6%B3%95%E9%9B%86/</guid>
      <description>一、什么是方法集 在go语言中，每个类型都有与之关联的方法，把这个类型的所有方法称为类型的方法集。例如：
type Student struct { age int8 name string } func (s Student) showName() { fmt.Println(s.name) } func (s *Student) setName(newName string) { s.name = newName } 类型 Student 的方法集包含 showName() 方法 类型 *Student 的方法集包含 showName()、setName() 方法
为什么呢？因为： 1、类型 T 方法集，包含全部 receiver T 方法 2、类型 *T 方法集，包含全部 receiver T + *T 方法
二、方法集和方法接受者的关系 在上面的案例中，类型 Student 的方法法集并不包含了 setName() 方法，那么是不是 Student 类型变量，就不能调用 setName() 方法呢？即下面调用，是否会报错呢？
s := Student{} s.setName(&amp;#34;lisi&amp;#34;) 其实，上面的调用是ok的。为什么呢？我们来回顾一下go语言的方法定义。
1、参数 receiver 可任意命名，如方法中，不适用参数，可以省略参数名。 2、参数 receiver 类型可以是 T 或 *T ，但类型 T 不能为接口或指针类型。 3、不支持方法重载。 4、可以实例 value 或 pointer 调用全部的方法，编译器会自动转换。</description>
    </item>
    
    <item>
      <title>Go协程调度</title>
      <link>https://hurace.github.io/post/go%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Fri, 09 Apr 2021 11:07:32 +0800</pubDate>
      
      <guid>https://hurace.github.io/post/go%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6/</guid>
      <description>单线程调度器0.x 多线程调度器1.0 任务窃取调度器1.1 抢占式调度器1.2  基于协作的抢占式调度器1.2 ～ 1.13 基于信号的抢占式调度器1.14 ～ 至今   非均匀存储访问调度器 - 提案  单线程调度器 0.x版本调度器只包含表示Goroutine的G和表示线程的M两种结构，全局也只有一个线程。
多线程调度器 整体逻辑与单线程调度器没有太多区别，因为我们的程序中可能同时存在多个活跃线程，所以多线程调度器引入了GOMAXPROCS变量帮助我们灵活控制程序中的最大处理器数，即活跃线程数。
该调度器有以下问题需要解决：
 调度器和锁是全局资源，所有的调度状态都是中心化存储的，锁竞争问题严重； 线程需要经常互相传递可运行的Goruntine，引入了大量的延迟； 每个线程都需要处理内存缓存，导致大量的内存占用并影响数据局部性； 系统调用频繁阻塞和解除阻塞正在运行的线程，增加了额外的开销；  任务窃取调度器 2012 年 Google 的工程师 Dmitry Vyukov 在 Scalable Go Scheduler Design Doc 中指出了现有多线程调度器的问题并在多线程调度器上提出了两个改进的手段：
 在当前的G-M模型中引入了处理器P，增加中间层； 在处理器P的基础上实现基于工作窃取的调度器；  当前处理器本地的运行队列中不包含Goroutine时，会触发工作窃取，从其他的处理器队列中随机获取一些Goruntine。
处理器持有一个由可运行的Goroutine组成的环形的运行队列runq，还反向持有一个线程。调度器在调度时会从处理器的队列中选择队列头的Goroutine放到线程M上执行。
抢占式任务调度 对 Go 语言并发模型的修改提升了调度器的性能，但是 1.1 版本中的调度器仍然不支持抢占式调度，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度。Go 语言的调度器在 1.2 版本4中引入基于协作的抢占式调度解决下面的问题：
 某些Goroutine可以长时间占用线程，造成其它Goroutine的饥饿； 垃圾回收需要暂停整个程序（Stop-the-World，STW），最长可能需要几分钟的时间，导致整个程序无法工作；  基于协作的抢占式调度 基于协作的抢占式调度的工作原理：
基于信号的抢占是调度 数据结构  G - 表示Goroutine，它是一个待执行的任务； M - 表示操作系统的线程，它由操作系统的调度器调度和管理； P - 表示处理器，它可以被看做运行在线程上的本地调度器；  G Goroutine是Go语言调度器中待执行的任务，它在调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销；</description>
    </item>
    
    <item>
      <title>Golang GC</title>
      <link>https://hurace.github.io/post/golang-gc/</link>
      <pubDate>Thu, 08 Apr 2021 21:51:40 +0800</pubDate>
      
      <guid>https://hurace.github.io/post/golang-gc/</guid>
      <description>golang垃圾回收机制 golang GC的发展  v1.1 STW v1.3 Mark STW，Sweep并行 v1.5 三色标记法 v1.8 hybrid write barrier  GC算法简介 引用计数（reference counting） 原理：每个单元维护一个域，保存其它单元指向它的引用数量。当引用数量为0时，将其回收。 在每个对象内部维护一个整数值，叫做这个对象的引用计数，当对象被引用是引用计数加1，当对象不被引用引用计数减1，当引用计数为0时，自动销毁对象。
GC不回收什么 在我们程序中会使用两种内存，分别是堆（heap）和栈（stack），GC不负责回收栈中的内存。那么这是为什么呢？
主要原因是栈是一块专用内存，专门为了函数执行而准备的，存储着函数中的局部变量以及调用栈。除此以外，栈中的数据都有一个特点——简单。比如局部变量就不能被函数外访问，所以这块内存用完就可以直接释放。正式因为这个特点，栈中的数据可以通过简单的编译器指令自动清理，也就不需要通过GC来回收了。
为什么需要垃圾回收 垃圾回收只负责回收堆中的数据。那么为什么堆中的数据需要自动垃圾回收呢？
其实早期的语言是没有自动垃圾回收的。比如在 C 语言中就需要使用 malloc/free 来人为地申请或者释放堆内存。这种做法除了增加工作量以外，还容易出现其他问题。
一种可能是并发问题，并发执行的程序容易错误地释放掉还在使用的内存。一种可能是重复释放内存，还有可能是直接忘记释放内存，从而导致内存泄露等问题。而这类问题不管是发现还是排查往往会花费很多时间和精力。所以现代的语言都有了这样的需求——一个自动内存管理工具。
什么是垃圾回收 我们说垃圾回收（Garbage Collection）的时候，其实说的是自动垃圾回收（Automatic Garbage Collection），一个自动回收堆内存的工具。
追踪式垃圾回收（Tracing Garbage Collection） 主流的垃圾回收算法有两种，分别是追踪式垃圾回收和引用计数（Reference Counting）。三色标记算法属于追踪是回收算法的一种。
追踪式算法的核心思想是判断一个对象是否可达，因为一旦这个对象不可达就可以GC回收了。那么怎么判断一个对象是否可达呢？第一步：找出所有的全局变量和当前函数栈里的变量，标记为可达。第二步：从已经标记的数据开始，进一步标记它们可访问的变量，以此类推，专业术语叫传递闭包。
为什么需要三色标记法 在三色标记法之前有一个算法叫做Mark-And-Sweeping（标记清除），这个算法是严格按照追踪式算法的思路来实现的。这个算法会设置一个标志位来记录对象是否被使用。最开始所有的标记位都是0，如果发现对象是可达的就会置为1，一步步下去就会呈现一个类似树状的结果。等标记的步骤完成后，会将未标记的对象统一清理，再次把所有标记位设置成0方便下次清理。
这个算法最大的问题是GC执行期间需要把整个程序完全暂停，不能异步进行GC操作。因为在不同阶段标记清除法的标识位0和1有不同的含义，那么新增的对象无论标记成什么都有可能意外删除这个对象。对实时性要求高的系统来说，这种需要长时间挂起的标记清除算法是不可接受的。所以就需要一个算法来解决GC运行时程序长时间挂起的问题，那就三色标记算法。
三色标记法好在哪里 相比传统标记清除算法，三色标记最大的好处是可以异步执行。从而可以以中断时间极少的代价或者完全没有中断来进行整个GC。
三色标记算法：首先将对象用三种颜色表示：白色、灰色、黑色。最开始所有对象都是白色的，然后把其中全局变量和函数栈里的对象置为灰色。第二步把灰色对象全部置为黑色，然后把原先灰色对象指向的变量都置为灰色，以此类推。等发现没有对象可以被置为灰色时，所有的白色变量就一定是需要被清理的垃圾了。
三色标记法因为多了一个白色的状态来存放不确定的对象，所以可以异步地执行。
一次完整的垃圾回 阶段一：Mark Setup 标记准备（STW：Stop The World） Write Barrier Write Barrier是什么呢？三色标记算法是一种可以并发执行的算法。所以在运行过程中程序的函数栈可能会有新分配的对象，那么这些对象该怎么通知到GC，怎么给它们着色呢？这个时候就需要Write Barrier。Write Barrier主要做这样一件事情，修改原先写的逻辑，然后在对象新增的同时给它着色，并且着色为“灰色”。因此打开了Write Barrier可以保证了三色标记法在并发下安全正确的运行。
Stop The World 在打开Write Barrier前有一个依赖，我们需要先停止所有的goroutine，也就是STW操作。那么接下来问题来了，GC该怎么通知所有的goroutine停止呢？
在停止goroutine的方案中，Go语言采取的是合作式抢占模式。这种模式的做法是在程序编译阶段注入额外的代码，更精确的说法是在每个函数序言中增加一个合作式抢占点。因为一个goroutine中通常有无数调用函数的操作，选择在函数序言中增加抢占点可以较好地平衡性能和实时性之间点利弊。在通常情况下，一次Mark Setup会在10～30微秒之间。</description>
    </item>
    
    <item>
      <title>Golang 变量逃逸</title>
      <link>https://hurace.github.io/post/golang%E5%8F%98%E9%87%8F%E9%80%83%E9%80%B8/</link>
      <pubDate>Thu, 08 Apr 2021 21:51:40 +0800</pubDate>
      
      <guid>https://hurace.github.io/post/golang%E5%8F%98%E9%87%8F%E9%80%83%E9%80%B8/</guid>
      <description>一、关于 堆和栈  栈 可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统
 申请到 栈内存 好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响
func f() { temp := make([]int,0,1) _ = temp } 可以使用go tool compile -m main.go|more或者go build -gcflags=-m main.go|more来查看是否存在变量逃逸
$ go tool compile -m main.go| more main.go:23:6: can inline main main.go:24:14: make([]int, 0) does not escape 类似于上面代码里面的temp变量，只是内函数内部申请的临时变量，并不会作为返回值返回，它就是被编译器申请到栈里面。
func foo() []int { temp := make([]int,0,1) return temp } $ go tool compile -m main.go| more main.go:3:6: can inline foo main.go:23:6: can inline main main.</description>
    </item>
    
  </channel>
</rss>
