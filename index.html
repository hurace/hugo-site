<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta name="generator" content="Hugo 0.82.0" />
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>晓瑞</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="stylesheet" href="/css/bundle.css">
	<link rel="icon" href="/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="/icons/32.png" sizes="32x32" type="image/png">
	<link rel="alternate" type="application/rss+xml" href="/index.xml" title="晓瑞">
		
</head>
<body class="body kind-home">
	<header class="header">
	<a class="logo" href="/">晓瑞</a>
	
<nav class="main-nav" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="/post/">
					
					<span class="main-nav__text">Archives</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
			<div class="cards">
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="/post/golang-gc/">Golang GC</a></h1>
	<div class="entry__content">golang垃圾回收机制 golang GC的发展  v1.1 STW v1.3 Mark STW，Sweep并行 v1.5 三色标记法 v1.8 hybrid write barrier  GC算法简介 引用计数（reference counting） 原理：每个单元维护一个域，保存其它单元指向它的引用数量。当引用数量为0时，将其回收。 在每个对象内部维护一个整数值，叫做这个对象的引用计数，当对象被引用是引用计数加1，当对象不被引用引用计数减1，当引用计数为0时，自动销毁对象。
GC不回收什么 在我们程序中会使用两种内存，分别是堆（heap）和栈（stack），GC不负责回收栈中的内存。那么这是为什么呢？
主要原因是栈是一块专用内存，专门为了函数执行而准备的，存储着函数中的局部变量以及调用栈。除此以外，栈中的数据都有一个特点——简单。比如局部变量就不能被函数外访问，所以这块内存用完就可以直接释放。正式因为这个特点，栈中的数据可以通过简单的编译器指令自动清理，也就不需要通过GC来回收了。
为什么需要垃圾回收 垃圾回收只负责回收堆中的数据。那么为什么堆中的数据需要自动垃圾回收呢？
其实早期的语言是没有自动垃圾回收的。比如在 C 语言中就需要使用 malloc/free 来人为地申请或者释放堆内存。这种做法除了增加工作量以外，还容易出现其他问题。
一种可能是并发问题，并发执行的程序容易错误地释放掉还在使用的内存。一种可能是重复释放内存，还有可能是直接忘记释放内存，从而导致内存泄露等问题。而这类问题不管是发现还是排查往往会花费很多时间和精力。所以现代的语言都有了这样的需求——一个自动内存管理工具。
什么是垃圾回收 我们说垃圾回收（Garbage Collection）的时候，其实说的是自动垃圾回收（Automatic Garbage Collection），一个自动回收堆内存的工具。
追踪式垃圾回收（Tracing Garbage Collection） 主流的垃圾回收算法有两种，分别是追踪式垃圾回收和引用计数（Reference Counting）。三色标记算法属于追踪是回收算法的一种。
追踪式算法的核心思想是判断一个对象是否可达，因为一旦这个对象不可达就可以GC回收了。那么怎么判断一个对象是否可达呢？第一步：找出所有的全局变量和当前函数栈里的变量，标记为可达。第二步：从已经标记的数据开始，进一步标记它们可访问的变量，以此类推，专业术语叫传递闭包。
为什么需要三色标记法 在三色标记法之前有一个算法叫做Mark-And-Sweeping（标记清除），这个算法是严格按照追踪式算法的思路来实现的。这个算法会设置一个标志位来记录对象是否被使用。最开始所有的标记位都是0，如果发现对象是可达的就会置为1，一步步下去就会呈现一个类似树状的结果。等标记的步骤完成后，会将未标记的对象统一清理，再次把所有标记位设置成0方便下次清理。
这个算法最大的问题是GC执行期间需要把整个程序完全暂停，不能异步进行GC操作。因为在不同阶段标记清除法的标识位0和1有不同的含义，那么新增的对象无论标记成什么都有可能意外删除这个对象。对实时性要求高的系统来说，这种需要长时间挂起的标记清除算法是不可接受的。所以就需要一个算法来解决GC运行时程序长时间挂起的问题，那就三色标记算法。
三色标记法好在哪里 相比传统标记清除算法，三色标记最大的好处是可以异步执行。从而可以以中断时间极少的代价或者完全没有中断来进行整个GC。
三色标记算法：首先将对象用三种颜色表示：白色、灰色、黑色。最开始所有对象都是白色的，然后把其中全局变量和函数栈里的对象置为灰色。第二步把灰色对象全部置为黑色，然后把原先灰色对象指向的变量都置为灰色，以此类推。等发现没有对象可以被置为灰色时，所有的白色变量就一定是需要被清理的垃圾了。
三色标记法因为多了一个白色的状态来存放不确定的对象，所以可以异步地执行。
一次完整的垃圾回 阶段一：Mark Setup 标记准备（STW：Stop The World） Write Barrier Write Barrier是什么呢？三色标记算法是一种可以并发执行的算法。所以在运行过程中程序的函数栈可能会有新分配的对象，那么这些对象该怎么通知到GC，怎么给它们着色呢？这个时候就需要Write Barrier。Write Barrier主要做这样一件事情，修改原先写的逻辑，然后在对象新增的同时给它着色，并且着色为“灰色”。因此打开了Write Barrier可以保证了三色标记法在并发下安全正确的运行。
Stop The World 在打开Write Barrier前有一个依赖，我们需要先停止所有的goroutine，也就是STW操作。那么接下来问题来了，GC该怎么通知所有的goroutine停止呢？
在停止goroutine的方案中，Go语言采取的是合作式抢占模式。这种模式的做法是在程序编译阶段注入额外的代码，更精确的说法是在每个函数序言中增加一个合作式抢占点。因为一个goroutine中通常有无数调用函数的操作，选择在函数序言中增加抢占点可以较好地平衡性能和实时性之间点利弊。在通常情况下，一次Mark Setup会在10～30微秒之间。</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="/post/golang%E5%8F%98%E9%87%8F%E9%80%83%E9%80%B8/">Golang 变量逃逸</a></h1>
	<div class="entry__content">一、关于 堆和栈  栈 可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统
 申请到 栈内存 好处：函数返回直接释放，不会引起垃圾回收，对性能没有影响
func f() { temp := make([]int,0,1) _ = temp } 可以使用go tool compile -m main.go|more或者go build -gcflags=-m main.go|more来查看是否存在变量逃逸
$ go tool compile -m main.go| more main.go:23:6: can inline main main.go:24:14: make([]int, 0) does not escape 类似于上面代码里面的temp变量，只是内函数内部申请的临时变量，并不会作为返回值返回，它就是被编译器申请到栈里面。
func foo() []int { temp := make([]int,0,1) return temp } $ go tool compile -m main.go| more main.go:3:6: can inline foo main.go:23:6: can inline main main.</div>
</article>
					</div>
			</div>
	</main>
	

	</div>
	<footer class="footer">
	<div class="footer__copyright">© 2021 晓瑞. <span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span></div>
</footer>
<script src="/js/menu.js"></script>
</body>
</html>